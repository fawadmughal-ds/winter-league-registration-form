import { NextRequest, NextResponse } from 'next/server';
import { sql } from '@/lib/db';
import { v4 as uuidv4 } from 'uuid';

// Generate cash slip ID
function generateSlipId(): string {
  const randomNum = Math.floor(1000 + Math.random() * 9000);
  return `WLG25-CASH-${randomNum}`;
}

// Generate online payment reference ID
function generateOnlineRefId(): string {
  const randomNum = Math.floor(1000 + Math.random() * 9000);
  return `WLG25-ONLINE-${randomNum}`;
}

// POST - Create new registration
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const {
      email,
      name,
      rollNumber,
      contactNumber,
      alternativeContactNumber,
      gender,
      selectedGames,
      teamMembers,
      totalAmount,
      paymentMethod,
      transactionId,
      screenshotUrl,
    } = body;

    // Validate required fields
    if (!email || !name || !rollNumber || !contactNumber || !gender || !selectedGames || !Array.isArray(selectedGames) || selectedGames.length === 0 || !paymentMethod || totalAmount === undefined || totalAmount === null) {
      return NextResponse.json(
        { error: 'Missing required fields', received: body },
        { status: 400 }
      );
    }

    const id = uuidv4();
    const slipId = paymentMethod === 'cash' ? generateSlipId() : generateOnlineRefId();
    const status = paymentMethod === 'cash' ? 'pending_cash' : 'pending_online';

    // Prepare data
    const selectedGamesJson = JSON.stringify(selectedGames);
    const teamMembersJson = teamMembers ? JSON.stringify(teamMembers) : null;
    const totalAmountNum = Number(totalAmount);
    
    console.log('Inserting registration:', {
      email,
      name,
      rollNumber,
      gender,
      selectedGamesCount: selectedGames.length,
      teamMembersCount: teamMembers ? Object.keys(teamMembers).length : 0,
      totalAmount: totalAmountNum,
      paymentMethod,
    });

    // Insert registration into database
    // Registration number will be auto-generated by the sequence
    const result = await sql`
      INSERT INTO registrations (
        id, email, name, roll_number, contact_number, alternative_contact_number,
        gender, selected_games, team_members, total_amount, payment_method, slip_id, transaction_id,
        screenshot_url, status, created_at, updated_at
      ) VALUES (
        ${id}, ${email}, ${name}, ${rollNumber}, ${contactNumber}, ${alternativeContactNumber || null},
        ${gender}, ${selectedGamesJson}, ${teamMembersJson}, ${totalAmountNum}, ${paymentMethod}, ${slipId}, ${transactionId || null},
        ${screenshotUrl || null}, ${status}, NOW(), NOW()
      )
      RETURNING registration_number
    `;

    const registrationNumber = result[0]?.registration_number;

    return NextResponse.json({
      success: true,
      registrationId: id,
      registrationNumber,
      slipId: slipId,
      status,
      totalAmount: Number(totalAmount),
    });
  } catch (error: any) {
    console.error('Registration error:', error);
    console.error('Error details:', {
      message: error.message,
      code: error.code,
      detail: error.detail,
      hint: error.hint,
    });
    return NextResponse.json(
      { error: 'Failed to create registration', details: error.message, code: error.code },
      { status: 500 }
    );
  }
}

// Force dynamic rendering and disable caching
export const dynamic = 'force-dynamic';
export const revalidate = 0;

// GET - Fetch all registrations (admin only)
export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const status = searchParams.get('status');
    const paymentMethod = searchParams.get('paymentMethod');
    const gender = searchParams.get('gender');
    const game = searchParams.get('game');
    const startDate = searchParams.get('startDate');
    const endDate = searchParams.get('endDate');

    console.log('API Filters received:', { status, paymentMethod, gender, game, startDate, endDate });

    // Build query with all filters using parameterized SQL (avoids nested template issues)
    let queryText = 'SELECT * FROM registrations';
    const whereClauses: string[] = [];
    const params: any[] = [];

    if (status) {
      params.push(status);
      whereClauses.push(`status = $${params.length}`);
    }
    if (paymentMethod) {
      params.push(paymentMethod);
      whereClauses.push(`payment_method = $${params.length}`);
    }
    if (gender) {
      params.push(gender);
      whereClauses.push(`gender = $${params.length}`);
    }
    if (startDate) {
      // Compare against created_date column (DATE type)
      params.push(startDate);
      whereClauses.push(`created_date >= $${params.length}`);
    }
    if (endDate) {
      params.push(endDate);
      whereClauses.push(`created_date <= $${params.length}`);
    }

    if (whereClauses.length > 0) {
      queryText += ' WHERE ' + whereClauses.join(' AND ');
    }
    queryText += ' ORDER BY created_at DESC';

    // Use the generic query helper to execute parameterized SQL
    const registrations = await sql(queryText, params) as any[];
    console.log(`Found ${registrations.length} registrations before game filter`);

    // Parse selected_games JSON for each registration
    let parsedRegistrations = registrations.map((reg: any) => {
      let selectedGames: string[] = [];
      try {
        if (typeof reg.selected_games === 'string') {
          selectedGames = JSON.parse(reg.selected_games);
        } else if (Array.isArray(reg.selected_games)) {
          selectedGames = reg.selected_games;
        }
      } catch (e) {
        selectedGames = [];
      }
      return {
        ...reg,
        selected_games: selectedGames,
      };
    });

    // Filter by game if specified (client-side filtering for JSON field)
    if (game) {
      const beforeCount = parsedRegistrations.length;
      parsedRegistrations = parsedRegistrations.filter((reg: any) => {
        return Array.isArray(reg.selected_games) && reg.selected_games.includes(game);
      });
      console.log(`Game filter "${game}": ${beforeCount} -> ${parsedRegistrations.length} registrations`);
    }

    console.log(`Returning ${parsedRegistrations.length} filtered registrations`);
    return NextResponse.json({ success: true, data: parsedRegistrations });
  } catch (error: any) {
    console.error('Fetch registrations error:', error);
    console.error('Error details:', {
      message: error.message,
      code: error.code,
      detail: error.detail,
      hint: error.hint,
      stack: error.stack,
    });
    return NextResponse.json(
      { 
        error: 'Failed to fetch registrations', 
        details: error.message,
        hint: error.hint || 'Check server console for full error details'
      },
      { status: 500 }
    );
  }
}
