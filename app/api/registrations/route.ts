import { NextRequest, NextResponse } from 'next/server';
import { sql } from '@/lib/db';
import { v4 as uuidv4 } from 'uuid';

// Generate cash slip ID
function generateSlipId(): string {
  const randomNum = Math.floor(1000 + Math.random() * 9000);
  return `WLG25-CASH-${randomNum}`;
}

// Generate online payment reference ID
function generateOnlineRefId(): string {
  const randomNum = Math.floor(1000 + Math.random() * 9000);
  return `WLG25-ONLINE-${randomNum}`;
}

// POST - Create new registration
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const {
      email,
      name,
      rollNumber,
      contactNumber,
      alternativeContactNumber,
      gender,
      selectedGames,
      teamMembers,
      totalAmount,
      paymentMethod,
      transactionId,
      screenshotUrl,
    } = body;

    // Validate required fields
    if (!email || !name || !rollNumber || !contactNumber || !gender || !selectedGames || !Array.isArray(selectedGames) || selectedGames.length === 0 || !paymentMethod || totalAmount === undefined || totalAmount === null) {
      return NextResponse.json(
        { error: 'Missing required fields', received: body },
        { status: 400 }
      );
    }

    const id = uuidv4();
    const slipId = paymentMethod === 'cash' ? generateSlipId() : generateOnlineRefId();
    const status = paymentMethod === 'cash' ? 'pending_cash' : 'pending_online';

    // Prepare data
    const selectedGamesJson = JSON.stringify(selectedGames);
    const teamMembersJson = teamMembers ? JSON.stringify(teamMembers) : null;
    const totalAmountNum = Number(totalAmount);
    
    console.log('Inserting registration:', {
      email,
      name,
      rollNumber,
      gender,
      selectedGamesCount: selectedGames.length,
      teamMembersCount: teamMembers ? Object.keys(teamMembers).length : 0,
      totalAmount: totalAmountNum,
      paymentMethod,
    });

    // Insert registration into database
    // Registration number will be auto-generated by the sequence
    const result = await sql`
      INSERT INTO registrations (
        id, email, name, roll_number, contact_number, alternative_contact_number,
        gender, selected_games, team_members, total_amount, payment_method, slip_id, transaction_id,
        screenshot_url, status, created_at, updated_at
      ) VALUES (
        ${id}, ${email}, ${name}, ${rollNumber}, ${contactNumber}, ${alternativeContactNumber || null},
        ${gender}, ${selectedGamesJson}, ${teamMembersJson}, ${totalAmountNum}, ${paymentMethod}, ${slipId}, ${transactionId || null},
        ${screenshotUrl || null}, ${status}, NOW(), NOW()
      )
      RETURNING registration_number
    `;

    const registrationNumber = result[0]?.registration_number;

    return NextResponse.json({
      success: true,
      registrationId: id,
      registrationNumber,
      slipId: slipId,
      status,
      totalAmount: Number(totalAmount),
    });
  } catch (error: any) {
    console.error('Registration error:', error);
    console.error('Error details:', {
      message: error.message,
      code: error.code,
      detail: error.detail,
      hint: error.hint,
    });
    return NextResponse.json(
      { error: 'Failed to create registration', details: error.message, code: error.code },
      { status: 500 }
    );
  }
}

// Force dynamic rendering and disable caching
export const dynamic = 'force-dynamic';
export const revalidate = 0;

// GET - Fetch all registrations (admin only)
export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const status = searchParams.get('status');
    const paymentMethod = searchParams.get('paymentMethod');
    const gender = searchParams.get('gender');

    // Build query dynamically based on filters
    let finalQuery;
    if (status && paymentMethod && gender) {
      finalQuery = sql`SELECT * FROM registrations WHERE status = ${status} AND payment_method = ${paymentMethod} AND gender = ${gender} ORDER BY created_at DESC`;
    } else if (status && paymentMethod) {
      finalQuery = sql`SELECT * FROM registrations WHERE status = ${status} AND payment_method = ${paymentMethod} ORDER BY created_at DESC`;
    } else if (status && gender) {
      finalQuery = sql`SELECT * FROM registrations WHERE status = ${status} AND gender = ${gender} ORDER BY created_at DESC`;
    } else if (paymentMethod && gender) {
      finalQuery = sql`SELECT * FROM registrations WHERE payment_method = ${paymentMethod} AND gender = ${gender} ORDER BY created_at DESC`;
    } else if (status) {
      finalQuery = sql`SELECT * FROM registrations WHERE status = ${status} ORDER BY created_at DESC`;
    } else if (paymentMethod) {
      finalQuery = sql`SELECT * FROM registrations WHERE payment_method = ${paymentMethod} ORDER BY created_at DESC`;
    } else if (gender) {
      finalQuery = sql`SELECT * FROM registrations WHERE gender = ${gender} ORDER BY created_at DESC`;
    } else {
      finalQuery = sql`SELECT * FROM registrations ORDER BY created_at DESC`;
    }

    const registrations = await finalQuery;

    // Parse selected_games JSON for each registration
    const parsedRegistrations = registrations.map((reg: any) => ({
      ...reg,
      selected_games: typeof reg.selected_games === 'string' 
        ? JSON.parse(reg.selected_games) 
        : reg.selected_games,
    }));

    return NextResponse.json({ success: true, data: parsedRegistrations });
  } catch (error: any) {
    console.error('Fetch registrations error:', error);
    return NextResponse.json(
      { error: 'Failed to fetch registrations', details: error.message },
      { status: 500 }
    );
  }
}
